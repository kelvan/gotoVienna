#!/usr/bin/env python
# -*- coding: UTF-8 -*-

from BeautifulSoup import BeautifulSoup, NavigableString
from urllib2 import urlopen
from urllib import urlencode
import settings
from datetime import datetime, time
from textwrap import wrap
import argparse
import sys
import os.path

from gotovienna.routing import *

parser = argparse.ArgumentParser(description='Get public transport route for Vienna')
parser.add_argument('-ot', metavar='type', type=str, help='origin type: %s' % ' | '.join(POSITION_TYPES), default='stop', choices=POSITION_TYPES)
parser.add_argument('-dt', metavar='type', type=str, help='destination type: %s' % ' | '.join(POSITION_TYPES), default='stop', choices=POSITION_TYPES)
parser.add_argument('origin')
parser.add_argument('destination')

args = parser.parse_args()
html = search((args.origin, args.ot), (args.destination, args.dt)).read()

parser = sParser(html)
state = parser.check_page()

if state == PageType.CORRECTION:
    try:
        cor = parser.get_correction()
        if cor[0]:
            print
            print '* Origin ambiguous:'
            lo = None
            while not lo or not lo.isdigit() or int(lo) > len(cor[0]):
                i = 1
                for c in cor[0]:
                    print '%d. %s' % (i, c)
                    i += 1
                lo = sys.stdin.readline().strip()

            args.origin = cor[0][int(lo) - 1]

        if cor[1]:
            print
            print '* Destination ambiguous:'
            ld = None
            while not ld or not ld.isdigit() or int(ld) > len(cor[1]):
                j = 1
                for c in cor[1]:
                    print '%d. %s' % (j, c)
                    j += 1
                ld = sys.stdin.readline().strip()

            args.destination = cor[1][int(ld) - 1]

        html = search((args.origin.encode('UTF-8'), args.ot), (args.destination.encode('UTF-8'), args.dt)).read()

        parser = sParser(html)
        state = parser.check_page()

    except ParserError:
        print 'PANIC at correction page'

if state == PageType.RESULT:
    parser = rParser(html)
    try:
        overviews = parser.overview
        details = parser.details
        l = ''
        while not l == 'q':
            for idx, overview in enumerate(overviews):
                if not overview['date'] or not overview['time']:
                    # XXX: Bogus data for e.g. Pilgramgasse->Karlsplatz?!
                    continue

                print '%d. [%s] %s-%s (%s)' % (idx + 1,
                        overview['date'],
                        overview['time'][0],
                        overview['time'][1],
                        overview['duration'])
            print 'q. Quit'
            l = sys.stdin.readline().strip()
            print
            print '~' * 100

            if l.isdigit() and int(l) <= len(details):
                for detail in details[int(l) - 1]:
                    if detail['time'] and detail['station']:
                        time = '%s - %s' % (detail['time'][0].strftime(TIMEFORMAT), detail['time'][1].strftime(TIMEFORMAT))
                        print '[%s] %s\n%s' % (time, ' -> '.join(detail['station']), '\n'.join(detail['info']))
                    else:
                        print '\n'.join(detail['info'])
                    print '-' * 100
            print

    except ParserError:
        print 'parsererror'

elif state == PageType.UNKNOWN:
    print 'PANIC unknown result'
